{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Infrastructure as Code (IaC)","text":"<p>Infrastructure as Code (IaC) is the practice of managing and provisioning infrastructure through machine-readable configuration files, rather than through manual processes. It enables automation, consistency, and scalability in infrastructure management.</p>"},{"location":"#why-iac","title":"Why IaC?","text":"<p>Traditional infrastructure provisioning involves manually configuring servers, networks, and storage, which is time-consuming, error-prone, and difficult to scale. IaC solves these challenges by treating infrastructure as software code.</p>"},{"location":"#key-benefits-of-iac","title":"Key Benefits of IaC:","text":"<ol> <li>Automation \u2013 Eliminates manual intervention, reducing human errors.</li> <li>Consistency \u2013 Ensures infrastructure is configured the same way across environments.</li> <li>Scalability \u2013 Easily replicate and scale infrastructure as needed.</li> <li>Version Control \u2013 Tracks changes, enabling rollback and auditing.</li> <li>Cost Efficiency \u2013 Reduces operational overhead by automating infrastructure management.</li> </ol>"},{"location":"#types-of-iac-approaches","title":"Types of IaC Approaches:","text":"<ol> <li>Declarative (What to achieve) \u2013 Defines the desired state of the infrastructure, and the tool ensures it matches. Examples: Terraform, Azure Bicep.</li> <li>Imperative (How to achieve it) \u2013 Defines step-by-step instructions to configure infrastructure. Examples: Ansible, scripts (Bash, PowerShell).</li> </ol>"},{"location":"#popular-iac-tools","title":"Popular IaC Tools:","text":"<ul> <li>Terraform \u2013 Open-source, cloud-agnostic IaC tool for provisioning and managing infrastructure.</li> <li>Azure Bicep \u2013 A domain-specific language (DSL) for deploying resources in Azure.</li> <li>AWS CloudFormation \u2013 Manages AWS infrastructure using JSON/YAML templates.</li> </ul>"},{"location":"#introduction-to-azure-bicep","title":"Introduction to Azure Bicep","text":"<p>Azure Bicep is a domain-specific language (DSL) developed by Microsoft for deploying Azure resources declaratively. It is designed as an alternative to JSON-based ARM templates, providing a more readable and maintainable syntax.</p>"},{"location":"#why-use-azure-bicep","title":"Why Use Azure Bicep?","text":"<ol> <li>Simplified Syntax \u2013 More concise and readable than ARM templates.</li> <li>Improved Modularity \u2013 Supports reusable modules for better maintainability.</li> <li>Better Tooling \u2013 Integrated with Visual Studio Code and Azure CLI for enhanced developer experience.</li> <li>Automatic Conversion \u2013 Can decompile existing ARM templates into Bicep code.</li> <li>No JSON Complexity \u2013 Eliminates the need for complex and verbose JSON structures.</li> </ol>"},{"location":"#key-features-of-azure-bicep","title":"Key Features of Azure Bicep","text":"<ul> <li>Declarative and Idempotent \u2013 Defines infrastructure as code, ensuring consistent deployments.</li> <li>Reusable Modules \u2013 Supports modular development for large-scale environments.</li> <li>Native Azure Integration \u2013 Works seamlessly with Azure Resource Manager (ARM) and Azure DevOps.</li> <li>Simplified Parameterization \u2013 Enables flexible and reusable configurations.</li> </ul>"},{"location":"#azure-bicep-vs-arm-templates","title":"Azure Bicep vs. ARM Templates","text":"Feature Azure Bicep ARM Templates Syntax Simple, readable Complex JSON Modularity Supports reusable modules No native modularity Tooling VS Code, Azure CLI Native Azure support Conversion Can decompile ARM to Bicep No direct conversion to Bicep"},{"location":"#which-one-to-choose","title":"Which One to Choose?","text":"<ul> <li>Use Azure Bicep if you want a simplified, modular, and maintainable approach to Azure resource deployment.</li> <li>Use ARM Templates if you need JSON-based definitions for legacy or existing automation processes.</li> </ul>"},{"location":"#1-install-azure-cli","title":"1. Install Azure CLI","text":"<p>Azure CLI is required to deploy Bicep files.</p>"},{"location":"#link-httpslearnmicrosoftcomen-uscliazureinstall-azure-cliinstall","title":"Link : https://learn.microsoft.com/en-us/cli/azure/install-azure-cli#install","text":""},{"location":"#common-structure-of-an-azure-bicep-file","title":"Common Structure of an Azure Bicep File","text":"<p>Over this example, for creating an Azure Storage Account using bicep</p>"},{"location":"#bicep-deployment","title":"Bicep deployment","text":"<p>You can view the JSON template you submitted to Resource Manager by using the bicep build command. In the next example, a Bicep template is converted into its corresponding JSON template</p>"},{"location":"#convert-bicep-to-json","title":"Convert Bicep to JSON","text":"<p>Run the following command: <pre><code>az bicep build --file .\\001\\001_stg.bicep\n</code></pre> Screenshot: The screenshot shows the JSON output generated from the Bicep file, confirming that the conversion process has executed successfully.</p> <p></p>"},{"location":"#preview-before-deployment","title":"Preview Before Deployment","text":"<p>The bicep what-if command is used to preview the changes that will be made to an Azure resource group before deploying a Bicep file. It provides a detailed summary of which resources will be created, modified, or deleted without actually making any changes.</p> <p><pre><code>az deployment group create --resource-group rgAppNameDev --template-file .\\001\\001_stg.bicep --what-if\n</code></pre> Screensort: </p>"},{"location":"#deploy-first-bicep-templaye","title":"Deploy First Bicep Templaye","text":""},{"location":"#using-az-cli","title":"Using Az Cli","text":"<pre><code>az deployment group create --resource-group rgAppNameDev --template-file .\\001\\001_stg.bicep\n</code></pre> <p>Post Deployment:  </p>"},{"location":"#bicep-parameter","title":"Bicep Parameter","text":"<p>Bicep parameters (param) allow you to pass values into a Bicep template, making it more reusable and configurable. Parameters help define inputs such as resource names, locations, or sizes, which can be provided at deployment time.</p>"},{"location":"#defining-bicep-parameter-with-annotations","title":"Defining Bicep Parameter with Annotations","text":"<pre><code>@description('The unique name for the storage account.')\n@minLength(3)\n@maxLength(24)\nparam storageAccountName string\n\n@description('The Azure region where the storage account will be deployed.')\n@allowed(['eastus', 'westus', 'centralindia'])\nparam location string\n\n@description('The SKU of the storage account.')\n@allowed(['Standard_LRS', 'Standard_GRS', 'Premium_LRS'])\nparam sku string\n\n@description('The kind of storage account.')\n@allowed(['StorageV2', 'BlobStorage', 'FileStorage'])\nparam kind string\n</code></pre>"},{"location":"#bicep-parameter-decorators","title":"Bicep Parameter Decorators","text":"Decorator Description <code>@description('...')</code> Adds a description for documentation purposes. <code>@allowed([...])</code> Restricts the parameter to specific values. <code>@minLength(n)</code> Ensures a minimum length for a string or array parameter. <code>@maxLength(n)</code> Ensures a maximum length for a string or array parameter. <code>@minValue(n)</code> Sets a minimum value for an integer parameter. <code>@maxValue(n)</code> Sets a maximum value for an integer parameter. <code>@secure()</code> Marks a parameter as sensitive, ensuring its value isn't logged or stored in deployment history."},{"location":"#parameters-files","title":"Parameters Files","text":"<p>Here\u2019s a generated parameter file (parameters.json) for your Bicep deployment</p> <p></p>"},{"location":"#deploy-infra-with-parameter-file","title":"Deploy Infra with Parameter file","text":"<pre><code>az deployment group create --resource-group rgAppNameDev --template-file 001/001_stg_param.bicep --parameters \"001/001_stg_param.parameters.json\"\n</code></pre>"},{"location":"#output-in-bicep","title":"Output in Bicep","text":"<p>In Bicep, the output keyword is used to return values from a deployment. These values can be used by other scripts, referenced in deployment pipelines, or checked after deployment.</p>"},{"location":"#basic-syntax","title":"Basic Syntax","text":"<pre><code>output &lt;outputName&gt; &lt;dataType&gt; = &lt;value&gt;\n</code></pre>"},{"location":"#checkout-the-code-for","title":"Checkout the code for","text":"<p>see bicepfile here</p>"},{"location":"#bicep-modules","title":"Bicep modules","text":"<p>Bicep modules are reusable Bicep files that help organize, reuse, and simplify infrastructure-as-code (IaC) deployments. They allow you to break down complex deployments into smaller, manageable components.</p>"},{"location":"#using-bicep-modules","title":"Using Bicep Modules","text":""},{"location":"#why-use-bicep-modules","title":"Why Use Bicep Modules?","text":"<p>\u2705 Code Reusability \u2013 Define once, use multiple times. \u2705 Better Organization \u2013 Break large templates into smaller files. \u2705 Improved Maintainability \u2013 Modify modules independently. \u2705 Encapsulation \u2013 Hide implementation details while exposing required parameters.  </p>"},{"location":"#example-using-bicep-modules","title":"Example: Using Bicep Modules","text":""},{"location":"#1-define-a-bicep-module","title":"1. Define a Bicep Module","text":"<p>Create a Bicep module file (<code>storage.bicep</code>) that defines a storage account:</p> <pre><code>param storageAccountName string\nparam location string = resourceGroup().location\nparam sku string = 'Standard_LRS'\n\nresource storage 'Microsoft.Storage/storageAccounts@2023-01-01' = {\n  name: storageAccountName\n  location: location\n  kind: 'StorageV2'\n  sku: {\n    name: sku\n  }\n}\n\noutput storageId string = storage.id\n</code></pre>"},{"location":"#2-use-the-module-in-a-main-bicep-file","title":"2. Use the Module in a Main Bicep File","text":"<p>Reference the module in your main Bicep file (<code>main.bicep</code>):</p> <pre><code>param storageAccountName string\nparam location string = resourceGroup().location\n\nmodule storageModule './storage.bicep' = {\n  name: 'storageDeployment'\n  params: {\n    storageAccountName: storageAccountName\n    location: location\n  }\n}\n</code></pre>"},{"location":"#3-deploy-using-azure-cli","title":"3. Deploy Using Azure CLI","text":"<p>Run the following command to deploy the Bicep template:</p> <pre><code>az deployment group create --resource-group &lt;ResourceGroupName&gt; --template-file main.bicep --parameters storageAccountName=&lt;YourStorageAccount&gt;\n</code></pre>"},{"location":"#benefits-of-using-modules","title":"Benefits of Using Modules","text":"<ul> <li>Simplifies complex deployments by breaking them into smaller, manageable components.</li> <li>Enhances collaboration by allowing teams to work on separate modules.</li> <li>Easier troubleshooting since each module can be tested independently.</li> <li>Improves security by exposing only necessary parameters while keeping implementation details hidden.</li> </ul> <p>By structuring your Bicep templates into reusable modules, you enhance scalability, maintainability, and clarity in your infrastructure as code (IaC) deployments. \ud83d\ude80</p>"},{"location":"toc/","title":"Toc","text":""},{"location":"toc/#table-of-contents","title":"Table of Contents","text":"Section Description Introduction to IaC Overview of Infrastructure as Code (IaC) Why IaC? Reasons to use IaC for infrastructure management Key Benefits of IaC Advantages like automation, consistency, and scalability Types of IaC Approaches Differences between Declarative and Imperative IaC Popular IaC Tools Overview of Terraform, Azure Bicep, and AWS CloudFormation Introduction to Azure Bicep Basics of Azure Bicep and its advantages Azure Bicep vs. ARM Templates Comparison of Bicep and ARM templates Installing Azure CLI Steps to install Azure CLI for Bicep deployment Common Structure of an Azure Bicep File Example of an Azure Storage Account deployment Bicep Deployment Converting Bicep to JSON using Azure CLI"}]}